# java面试



互联网三高
高可用

高扩展

高性能（高并发，低延迟）
性能优化
1：优化响应速度(优化业务复杂度，各级缓存，jvm的优化，)
2：优化吞吐量（搭建各种集群（mysql,redis,hadoop,kafka,）



基本概要：
1：线程相关问题          （深入了解线程池，AQS,)
Threadpoolexculator   

线程池
最大连接数
核心线程数
最小线程数

线程池满了之后线程继续如何解决
等待 锁






2: 集合相关问题          （set map list 需要对hashmap进行一些深入的了解）

为什么不用HashMap 
因为HashMap是线程不安全的，所以一般在高并发的情况下不需要HashMap
用的是CurrentHashMap

Hashmap是线程不安全的，jdk1.7之前使用数组+双向链表来组成HashMap
jdk1.8之后使用链表+红黑树









3：数据库的索引相关问题    (数据库索引和B+树的一些存储问题)




数据库缓存和B+树储存





4：redis数据库相关问题     （缓存+redis数据库设计的相关问题，多线程相关问题，缓存穿透）



redis缓存雪崩 （加一层）

redis单线程和多线程 

加快数据的相关缓存速度










5：java锁的一些问题      （包括死锁，解锁，轻量级锁，自旋锁等一系列问题）




锁机制










6: karfa rubbitMQ的相关消息队列





消息队列来自第三方插件，需要使用kafka rubbitmq 来进行相关的开发









7：相关项目经验          （单点登录（技术点） 一般的增删改查 后台数据，springboot微服务 如何通信 如何服务降级熔断 断电即失的相关解决办法 如何）


eureka节点挂了80%之后会自动保存相关节点，在这之前Eureka有相关的心跳机制来判断相关节点是否存在
一般通过https或者socket来实现相关的通信，但底层还是实现了相关的tcp/ip
断电即失
一种是将内存里的东西直接写在硬盘，但是过程中会有相关的io流读写，在效率有一定的问题

一种是分布式的解决方案利用分布式系统，将本机的相关数据直接读取强制缓存到其他机子

服务降级



8:linux相关运维知识       (对于tomcat+jdk+nginx+docker等相关的问题)

linux相关知识暂时用了不少
对于一般的单体应用差不多了




9：大数据等相关经验        （对于hadoop+zookeeper+HBase+Hive+mongodb+redis+flume）

大数据的相关东西还是比较重要的，hadoop是一个分布式文件系统，zookeeper+dubbo为一般的分布式系统提供了相当可观的解决方案，Hive和Hbase又提高了数据的相关处理和缓存




10：算法问题                (唯一id生成的相关雪花算法+Java基础排序算法+优化相关算法+基础算法)

雪花算法问题一般会在用户的uuid来进行相关的使用（现在不推荐使用）






arraylist
基于动态数组，连续存储
适合下标访问
扩容机制
 固定数组，扩容需要新建数组，将老数组拷贝到新数组


linklist
基于链表，不连续储存，适合做插入及删除操作 ，不适合查询
需要逐一遍历
便利需要用到迭代器用for循环取值需要对list重新遍历
不要使用indexof返回索引，当结果为空的时候会遍历整个列表



HashMap和HashTable的区别基于底层的相关实现


hashMap线程不安全，允许k-value为null,hashTable不允许
HashTable每一个方法都加了锁，所以hashtable的线程安全的
jdk8开始链表高度到8，数组长度超过64，链表转换成红黑树（平衡二叉树）

1计算key的hash值，二次hash然后对数组长度取模，对应到数组下标
如果没有产生Hash冲突（该节点没有元素），则直接创建node 存入数组

如果产生Hash冲突，先进行equals的相关比较，长度低于6位直接转回链表。


key为null,存在下标为0的位置

数组扩容
基于扩容因子（0.75）
重新创建数组，将旧数组放进新数组


concurrentMap 线程安全的HashMap
JDK7
相关数据结构
ReentrantLock+segment+HashEntry ,一个segment包含一个HashEntry数组，每个HashEntry又是一个链表结构
元素查询
二次Hash，第一次hash定位到Sgement,第二次定位到链表头部

锁
segment分段锁，segment继承了ReentrantLock,锁定操作的segment，其他的segment不受影响，并发度为segment个数，可以通过构造函数指定，数组扩容不会影响其他的segment
get方法无需加锁，volatile保证可见性（防止读到脏数据）

jdk8
数据结构
synchornized+CAS+node+红黑树 ,
node的val和next都用volatile修饰，保证可见性
查找 替换，赋值操作都用CAS

锁：链表结构的head节点，不影响其它元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作，并发扩容


读操作是无锁的
Node的val和next使用volita修饰，读写线程对变量相互可见
数组 用volita修饰，保证扩容时被线程感知


如何实现一个ioc容器（简单）

1：配置文件，配置包扫描路径
2：递归包扫描获取.class文件
3:反射，确定需要交给ioc管理实现的类
4：对需要注入的类进行依赖注入


配置文件中指定需要扫描的包路径
定义一些注解，分别表示访问控制层，业务服务层，数据持久层，依赖注入注解 获取配置文件详解
从配置文件中获取需要扫描的包路径，获取到当前路径下的文件信息及文件夹信息，我们将当前路径下所有以.class结尾的文件添加到一个set集合中进行储存
遍历这个set集合，获取在这个类上的有指定注解的类，将其交给ioc容器，定义一个安全的Map用来储存的这些东西
遍历这个ioc容器，获取到每一个类的实例，判断里面吗是否有以来其他类的实例，然后进行递归注入

aop如何理解


系统是由许多不同的组件组成的，每一个组件负责一块特定的功能，除了实现自身的核心功能之外，这些组件还经常承担着其他的职责，例如，日志，事务管理和安全这样的核心服务经常融入自身具有的核心业务逻辑的组件中去。
当我们需要为分散对象引入公共行为的时候，oop则显得无能为力，也就是说，oop允许你定义从上而下的关系，但并不适合定义从左到右的关系，例如日志功能
日志代码往往水平地散布在所有对象层级中，而与它所散布到的对象的核心功能毫无关系
在oop设计中，它导致了大量的重复代码，从不利于各个模块的重用
aop:将程序中的交叉业务逻辑，封装成一个切面（安全，日志，事务），然后注入到目标对象（具体业务逻辑），aop可以对某个对象或某些对象的功能进行增强，比如对象中的方法进行增强，可以在执行某个方法之前的额外的做一些事情，在某个方法之后额外做一些事情



java类加载器
JDK自带三个类加载器
bootstrap ClassLoader是ExtClassLoader的父加载器，默认负责加载%JAVA_HOME%的lib下的jar包和class文件

ExtClassLoader（扩展） 是application的父加载器，默认负责加载%JAVA_HOME% lib/ext下的jar包和class文件
AppClassLoader是自定义加载器的父类，负责加载classpath下的类文件
继承ClassLoader实现自定义类加载器

双亲委派机制
向上委派，向下查找

appclassloader 加载一个类的时候会向上委派，查找缓存，查到顶层之后，缓存中没有，则到加载路径中查找，有则加载返回，没有则向下查找（查找加载路径）

为了安全性，避免用户自己编写的类动态替换java的一些核心类
同时避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的CLASSLOADER加载就是不同类



Java中的异常体系
java中最顶级的类叫THROWABLE
exception error
error:无法处理的错误，导致终止
oom
exception
某一个方法或调用出问题，基本可以处理，不会导致终止，exception又分为checkexeption和runtimeexception
我们比较关注的是运行时错误
checkexception发生在程序编写编译过程中，会导致程序编译不通过
runtimeexception发生在程序运行过程中，会导致程序当前线程执行失败















缓存雪崩，缓存穿透，缓存击穿
缓存雪崩是指缓存同一时间大面积的失效，所以，后面的请求都会落在数据库上，造成数据库短时间内承受大量的请求而崩掉



解决方案
缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果换内存失效，更新数据缓存
缓存预热
互斥锁


缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都会落在数据库上，造成数据库短时间承受大量请求而崩掉


解决方案


接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截

从缓存取不到的数据，在数据库中也没有取到，这时候可以将key=value改成key=null ,缓存有效时间可以设置短点，如
30秒（设置太长也会导致正常情况下没法使用），这样可以防止攻击用户反复使用一个id暴力攻击

采用布隆过滤器，将所有可能存在的数据hash到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免了对底层存储系统的查询压力

缓存击穿


缓存击穿是指缓存中有但是数据库中没有的数据（一般是缓存时间到期），这时由于并发用户比较多
同时读缓存没读取到数据，又同时去数据库去读取数据，引起数据库压力过大，造成过大压力，和缓存雪崩不同的是，缓存
击穿指并发查同一条数据，缓存雪崩是不同的数据过期了，很多数据都查不到而去查找数据库
























什么是spring 

轻量级的开源框架，是一个装javabean的中间层框架
可以起一个连接作用
比如连接strusts和hibernate粘合在一起使用
可以让我们的企业开发更快，更简洁

spring是一个轻量级的控制反转和面向切面编程的容器框架


从大小和量级来说spring都是轻量级的

通过反转IOC的技术达到松耦合的目的
提供了面向切面编程的丰富支持，允许通过分离式的业务逻辑与系统级服务进行内聚性的开发
包含并管理应用对象（bean）的生命周期，这个意义上是一个容器
将简单的组件配置，组合成复杂的应用，这个意义是一个框架













































